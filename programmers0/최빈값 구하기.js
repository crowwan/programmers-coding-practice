// Map은 배열과 같은 형태입니다. 다만 요소를 [키, 값]형태로 객체처럼 받습니다. [[1,2]]
// 배열처럼 인덱스로 요소에 접근하는 것이 불가능합니다.
// 객체처럼 키를 이용해 접근하고 이때 get(키) 메소드를 사용해서 값을 얻을 수 있습니다.
// 해당 키에 새로운 값을 넣고 싶을 때는 set(키, 값)을 사용합니다. 이미 있는 키면 값이 갱신되고, 없는 키면 새로 추가합니다. 이 역시 객체와 같습니다.

// 이 문제에서 배열을 사용해서 최빈값들을 저장하면 순서가 보장되지 않기 때문에 인덱스와 요소의 값이 같지 않을 수 있습니다. (최빈값을 저장한 배열이 [[3,2],[2,2]] 일때, 3을 찾고 싶으면 [3][0] 이런식으로 찾을 수 없다는 뜻입니다.)
// 즉, 키를 알고 있을 때, 최빈값을 저장한 배열에서 값을 찾기 위해서 순회가 불가피합니다.
// 객체를 이용하면 키를 알고 있을 때, 순회없이 값에 접근할 수 있고, 해당 키에 새로운 값을 넣을 때도 새로 키를 생성하는 것이 아닌 이미 있는 키는 값만 갱신합니다.
// 하지만 객체는 for...of문으로 순회하기 위해서 Object.keys를 사용해야 합니다.
// Map은 배열과 같이 for...of문으로 순회가 가능하고, 객체와 같이 키를 이용해 값에 접근하고 갱신할 수 있습니다.
// 단점은 배열처럼 인덱스로 값을 접근할 수 없기 때문에 키를 모를 때는 순회를 해서 값을 찾아야 한다는 것입니다.

function solution(array) {
  const mostFre = new Map([]); // 최대 빈도수를 가진 요소들을 [요소, 빈도수] 형태로 저장합니다.
  let freq = 0; // 현재 최빈값의 빈도수를 저장합니다.
  const freqMap = {}; // 각 요소를 키로하고 빈도수를 값으로 하는 객체입니다.

  for (const a of array) {
    // 배열을 순회하면서 각 요소의 빈도수를 설정합니다.
    freqMap[a] = freqMap[a] ? freqMap[a] + 1 : 1;

    // 현재 요소의 빈도수가 최빈값의 빈도수와 같을 경우
    if (freqMap[a] === freq) {
      // 현재 요소도 최빈값이라는 의미이므로 최빈값을 저장하는 mostFre에 추가합니다.
      mostFre.set(a, freqMap[a]);
    } else if (freqMap[a] > freq) {
      // 현재 요소의 빈도수가 최빈값의 빈도수보다 클 경우
      // 최빈값이 현재 요소이므로 최대 빈도수를 현재 요소의 빈도수로 바꿔줍니다.
      freq = freqMap[a];
      // 최빈값을 저장하는 mostFre에 있는 값들은 이제는 최빈값이 아니기 때문에 모두 지워줍니다.
      mostFre.clear();
      // 현재 요소를 mostFre에 저장합니다.
      mostFre.set(a, freqMap[a]);
    }
  }

  // mostFre에 요소가 2개 이상이면, 최빈값이 2개 이상이라는 의미이므로 -1을 반환합니다.
  // 그렇지 않으면, 현재 mostFre에는 요소가 한 개만 있고, 그 요소가 최빈값이므로 그 요소를 반환합니다.
  return mostFre.size > 1 ? -1 : mostFre.keys().next().value;
}

//  mostFre.keys().next().value;
// Map은 인덱스 접근이 불가능 하기 때문에 이와 같은 형태로 결과를 반환했습니다. 아쉽게도 Map.keys()는 Object.keys()와 달리 배열을 리턴하지 않습니다. 인덱스로 접근이 불가능하다는 의미입니다.

// 대신, [...mostFre][0][0]으로 2차원 배열로 변환 후 첫 요소의 첫번째 값(여기선 최빈값)을 반환해도 됩니다.
